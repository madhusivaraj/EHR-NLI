"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const readline_1 = require("readline");
const fs_1 = require("fs");
const morphItPath = 'resources_src/morph-it/morph-it_048.txt';
const lineReader = readline_1.createInterface({
    input: fs_1.createReadStream(morphItPath, { encoding: 'latin1' }),
});
console.log('starting to process morph-it file: ' + morphItPath);
const nouns = {};
const adjectives = {};
const pastParticiples = {};
try {
    lineReader
        .on('line', function (line) {
        const lineData = line.split('\t');
        if (lineData.length != 3) {
            return;
        }
        const flexform = lineData[0];
        const lemma = lineData[1];
        const props = lineData[2].split(':');
        if (props.length != 2) {
            return;
        }
        const derivational = props[0].split('-');
        const inflectional = props[1].split('+');
        if (derivational.length < 1) {
            return;
        }
        const nature = derivational[0];
        if (nature != 'NOUN' && nature != 'ADJ' && nature != 'VER') {
            return;
        }
        if (nature === 'ADJ' && inflectional.indexOf('pos') === -1) {
            return;
        }
        if (nature === 'VER' && (inflectional.indexOf('part') === -1 || inflectional.indexOf('past') === -1)) {
            return;
        }
        let gender;
        let number;
        switch (nature) {
            case 'NOUN': {
                if (derivational.indexOf('M') > -1) {
                    gender = 'M';
                }
                else if (derivational.indexOf('F') > -1) {
                    gender = 'F';
                }
                break;
            }
            case 'VER':
            case 'ADJ': {
                if (inflectional.indexOf('m') > -1) {
                    gender = 'M';
                }
                else if (inflectional.indexOf('f') > -1) {
                    gender = 'F';
                }
                break;
            }
        }
        if (inflectional.indexOf('s') > -1) {
            number = 'S';
        }
        else if (inflectional.indexOf('p') > -1) {
            number = 'P';
        }
        if (!gender || !number) {
            console.log(`incomplete: ${line}`);
        }
        const natureMapping = {
            VER: 'PP',
            ADJ: 'ADJ',
            NOUN: 'NOUN',
        };
        const targetNature = natureMapping[nature];
        /*
          adjectives
            nature='ADJ' OR nature='PP'
            key: lemma or flexform
            val: lemma, nature
        */
        if (targetNature === 'ADJ' || targetNature === 'PP') {
            const isPp = targetNature === 'PP';
            adjectives[lemma] = adjectives[flexform] = [lemma, isPp];
        }
        /*
          pastParticiples
            nature='PP' AND gender='M' AND number='S'
            key: lemma
            val: flexform
        */
        if (targetNature === 'PP' && gender === 'M' && number === 'S') {
            pastParticiples[lemma] = flexform;
        }
        /*
          nouns
            nature='NOUN'
            key: lemma or flexform
            val: lemma
        */
        if (targetNature === 'NOUN') {
            nouns[lemma] = nouns[flexform] = lemma;
        }
    })
        .on('close', function () {
        fs_1.writeFileSync('resources_pub/nouns.json', JSON.stringify(nouns), 'utf8');
        fs_1.writeFileSync('resources_pub/adjectives.json', JSON.stringify(adjectives), 'utf8');
        fs_1.writeFileSync('resources_pub/pastParticiples.json', JSON.stringify(pastParticiples), 'utf8');
        console.log('done.');
    });
}
catch (err) {
    console.log(err);
}
//# sourceMappingURL=createDb.js.map