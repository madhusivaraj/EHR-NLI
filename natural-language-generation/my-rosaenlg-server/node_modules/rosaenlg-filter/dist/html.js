"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.blockLevelElts = [
    'address',
    'article',
    'aside',
    'blockquote',
    'canvas',
    'dd',
    'div',
    'dl',
    'dt',
    'fieldset',
    'figcaption',
    'figure',
    'footer',
    'form',
    'h1',
    'h2',
    'h3',
    'h4',
    'h5',
    'h6',
    'header',
    'hr',
    'li',
    'main',
    'nav',
    'noscript',
    'ol',
    'p',
    'pre',
    'section',
    'table',
    'tfoot',
    'ul',
    'video',
    // special ones
    'li_block',
    'ul_block',
    'ol_block',
];
exports.inlineElts = [
    'a',
    'abbr',
    'acronym',
    'b',
    'bdo',
    'big',
    'br',
    'button',
    'cite',
    'code',
    'dfn',
    'em',
    'i',
    'img',
    'input',
    'kbd',
    'label',
    'map',
    'object',
    'output',
    'q',
    'samp',
    'script',
    'select',
    'small',
    'span',
    'strong',
    'sub',
    'sup',
    'textarea',
    'time',
    'tt',
    'var',
    // special ones
    'li_inline',
    'ul_inline',
    'ol_inline',
];
function replaceHtml(input) {
    // console.log(input);
    const replacedHtml = { replaced: null, elts: [] };
    const regexHtml = new RegExp('<(/?)([a-zA-Z_]+).*?>', 'g'); // _ to support li_*
    replacedHtml.replaced = input.replace(regexHtml, function (match, begin, tag) {
        // console.log(`match: ${match} / tag: ${tag}`);
        replacedHtml.elts.push(match);
        if (exports.blockLevelElts.indexOf(tag) > -1) {
            if (begin === '/') {
                return '☚';
            }
            else {
                return '☛';
            }
        }
        else {
            // inlineElts or other
            if (begin === '/') {
                return '☜';
            }
            else {
                return '☞';
            }
        }
        // console.log(`rosaenlg-filtering: html tag nature unknown: ${tag} => considered as inline elt`);
    });
    return replacedHtml;
}
exports.replaceHtml = replaceHtml;
function cleanReplacedTag(tag) {
    return tag.replace('_block', '').replace('_inline', '');
    /*
      .replace('li_block', 'li')
      .replace('li_inline', 'li')
      .replace('ul_block', 'ul')
      .replace('ul_inline', 'ul')
      .replace('ol_block', 'ol')
      .replace('ol_inline', 'ol');
    */
}
function replacePlaceholders(input, elts) {
    // console.log(input);
    const regexPlaceholder = new RegExp('[☛☚☞☜]', 'g');
    const res = input.replace(regexPlaceholder, function (match, placeholder) {
        //console.log(`match: ${match} / tag: ${placeholder}`);
        const tag = elts.shift();
        //console.log(tag);
        if (typeof tag === 'undefined') {
            const err = new Error();
            err.name = 'InternalError';
            err.message = `There are not enough html tags`;
            throw err;
        }
        return cleanReplacedTag(tag);
    });
    if (elts.length > 0) {
        const err = new Error();
        err.name = 'InternalError';
        err.message = `There are left html tags: ${elts}`;
        throw err;
    }
    return res;
}
exports.replacePlaceholders = replacePlaceholders;
const protectMap = {
    AMPROTECT: '&amp;',
    LTPROTECT: '&lt;',
    GTPROTECT: '&gt;',
};
function protectHtmlEscapeSeq(input) {
    let res = input;
    for (const key in protectMap) {
        res = res.replace(protectMap[key], key);
    }
    return res;
}
exports.protectHtmlEscapeSeq = protectHtmlEscapeSeq;
function unProtectHtmlEscapeSeq(input) {
    let res = input;
    for (const key in protectMap) {
        res = res.replace(key, protectMap[key]);
    }
    return res;
}
exports.unProtectHtmlEscapeSeq = unProtectHtmlEscapeSeq;
//# sourceMappingURL=html.js.map