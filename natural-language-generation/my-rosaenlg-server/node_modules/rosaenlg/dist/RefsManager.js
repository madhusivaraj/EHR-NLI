"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class RefsManager {
    constructor(saveRollbackManager, genderNumberManager, randomManager) {
        this.saveRollbackManager = saveRollbackManager;
        this.genderNumberManager = genderNumberManager;
        this.randomManager = randomManager;
        this.triggeredRefs = new Map();
        this.nextRefs = new Map();
    }
    setSpy(spy) {
        this.spy = spy;
    }
    getNextRefs() {
        return this.nextRefs;
    }
    setNextRefs(nextRefs) {
        this.nextRefs = nextRefs;
    }
    getTriggeredRefs() {
        return this.triggeredRefs;
    }
    setTriggeredRefs(triggeredRefs) {
        this.triggeredRefs = triggeredRefs;
    }
    getNextRef(obj) {
        return this.nextRefs.get(obj);
    }
    setNextRef(obj, nextRef) {
        this.nextRefs.set(obj, nextRef);
    }
    getNextRep(obj, params) {
        // debug('GET NEXT REF');
        // there's already one planned
        if (this.getNextRef(obj)) {
            // debug('already one planned');
            return this.getNextRef(obj);
        }
        if (!obj) {
            const err = new Error();
            err.name = 'InvalidArgumentError';
            err.message = `getNextRep called on null object`;
            throw err;
        }
        // simulate
        const rndNextPosBefore = this.randomManager.getRndNextPos();
        this.saveRollbackManager.saveSituation('nextRep');
        const hadRefBefore = this.hasTriggeredRef(obj);
        // debug('hadRefBefore: ' + hadRefBefore);
        const lengthBefore = this.spy.getPugHtml().length;
        // cross dependency prevents from calling the function directly
        this.spy.getPugMixins().value(obj, params);
        // record the result before rollback
        const nextRef = {
            valueForDebug: this.spy.getPugHtml().substring(lengthBefore),
            // we don't care about what will be triggered, but only if it has been triggered before
            REPRESENTANT: hadRefBefore ? 'refexpr' : 'ref',
            gender: this.genderNumberManager.getRefGender(obj, null),
            number: this.genderNumberManager.getRefNumber(obj, null),
            rndNextPos: rndNextPosBefore,
        };
        // debug("getNextRep will be:" + JSON.stringify(nextRef));
        // rollback
        // pug_html = html_before;
        this.saveRollbackManager.rollback();
        // register the result
        // debug(`BBB ${nextRef.gender} ${nextRef.number}`);
        this.genderNumberManager.setRefGenderNumber(nextRef, nextRef.gender, nextRef.number);
        // save the nextRef for use when it will actually be triggered
        this.setNextRef(obj, nextRef);
        return nextRef;
    }
    resetRep(obj) {
        this.triggeredRefs.delete(obj);
        // if we had asked for a next ref
        this.nextRefs.delete(obj);
    }
    hasTriggeredRef(obj) {
        return this.triggeredRefs.get(obj);
    }
    setTriggeredRef(obj) {
        this.triggeredRefs.set(obj, true);
    }
    deleteNextRef(obj) {
        this.nextRefs.delete(obj);
    }
}
exports.RefsManager = RefsManager;
//# sourceMappingURL=RefsManager.js.map